version: '3.8'

services:
  traffic-monitor:
    image: kaazing/tcpdump
    container_name: traffic_monitor
    # Use 'network_mode: service:target_service_name' to monitor a specific service
    # or 'network_mode: "host"' to capture all host traffic (on Linux/Mac)
    # The 'service' approach requires the target service to be running.
    # The 'host' approach is easier for general local traffic capture.
    #network_mode: "host"
    network_mode: service:django
    volumes:
      - ./tcpdump_data:/tcpdump_data # Mount a local dir to save capture files
    command: -i any -w /tcpdump_data/capture.pcap -C 10

  db:
    image: mysql:8.0 # Use a specific MySQL version
    container_name: mysql_db
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: your_root_password
      MYSQL_DATABASE: django_db
      MYSQL_USER: django_user
      MYSQL_PASSWORD: django_password
    ports:
      - "3306:3306"
    volumes:
      - db_data:/var/lib/mysql # Persist database data
    networks:
      - app-network
    healthcheck:
        test: mysqladmin ping -h 127.0.0.1 -u $$MYSQL_USER --password=$$MYSQL_PASSWORD
        start_period: 5s
        interval: 5s
        timeout: 5s
        retries: 55

  django:
    build: ./django # Build from the django/ directory with a Dockerfile
    container_name: django_app
    #command: sh -c "python manage.py migrate && python manage.py runserver 0.0.0.0:8000" # Run migrations and then start the app
    command: sh -c "python manage.py migrate && python manage.py collectstatic --noinput && gunicorn --bind 0.0.0.0:8000 my_docker_django_app.wsgi:application" 
    #command: sh -c "python manage.py migrate" 
    volumes:
      - ./django:/app # Mount your project code
    environment:
      #DATABASE_HOST: mysql_db # Use the service name as the hostname
      DATABASE_HOST: db # Use the service name as the hostname
      DATABASE_NAME: django_db
      DATABASE_USER: django_user
      DATABASE_PASSWORD: django_password
    ports:
      - "8000:8000"
    networks:
      - app-network
    depends_on:
      db:
        condition: service_healthy

  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    container_name: phpmyadmin_container
    environment:
      PMA_HOST: db # Connect to the 'db' service name
      MYSQL_ROOT_PASSWORD: your_root_password
    #ports:
    #  - "8081:80" # Access phpMyAdmin at http://localhost:8081
    networks:
      - app-network
    depends_on:
      - db

  nginx_django:
    image: nginx:alpine
    container_name: nginx_django_reverse_proxy
    ports:
      #- "80:80"
      - "443:443" # Expose port 443 to the host
    volumes:
      # Mount Nginx configuration and SSL certificates
      - ./nginxdjangoconfig/nginx/conf.d:/etc/nginx/conf.d:ro
      - ./nginxdjangocerts/certs/ssl:/etc/nginx/ssl:ro
      - ./django:/app # Mount your project code
    networks:
      - app-network    
    depends_on:
      - django

  nginx:
    image: nginx:alpine
    container_name: nginx_reverse_proxy
    ports:
      #- "80:80"
      - "8443:443" # Expose port 443 to the host
    volumes:
      # Mount Nginx configuration and SSL certificates
      - ./nginxconfig/nginx/conf.d:/etc/nginx/conf.d:ro
      - ./nginxcerts/certs/ssl:/etc/nginx/ssl:ro
    networks:
      - app-network
    depends_on:
      - phpmyadmin

#  apache:
#    image: httpd:2.4 # Use an Apache base image
#    container_name: apache_web
#    ports:
#      - "80:80" # Map host port 80 to container port 80
#    volumes:
#      - ./django/static:/usr/local/apache2/htdocs/static # Mount Django static files
#      - ./apache/apache2.conf:/usr/local/apache2/conf/apache2.conf # Custom Apache config
#      - ./apache/000-default.conf:/usr/local/apache2/conf/sites-enabled/000-default.conf # Virtual host config
#    depends_on:
#      - django # Ensure Django app is running

volumes:
  db_data:
  nginx_config:

networks:
  app-network:
    driver: bridge


